<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Jitter Tool - Web Version</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1 {
            color: #333;
            text-align: center;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h2 {
            margin-top: 0;
            color: #555;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            font-family: monospace;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
        }
        
        .config-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .value-display {
            display: inline-block;
            width: 50px;
            text-align: right;
            font-family: monospace;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
        }
        
        .checkbox-group input {
            margin-right: 8px;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        #preview-container {
            position: relative;
            min-height: 300px;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            overflow: hidden;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
        }
        
        #preview-container svg {
            width: 100%;
            height: 100%;
            display: block;
            transform-origin: center center;
        }
        
        .instructions {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .hidden {
            display: none;
        }
        
        .preview-controls {
            margin-bottom: 10px;
        }
        
        .preview-controls button {
            margin-right: 10px;
            padding: 5px 10px;
            font-size: 14px;
        }
        
        #zoom-level {
            font-weight: bold;
            margin-left: 10px;
        }
        
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 4px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
            background-color: #f9f9f9;
        }
        
        .drop-zone:hover {
            background-color: #f0f0f0;
        }
        
        .drop-zone p {
            margin: 0;
            color: #666;
        }
        
        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #666;
        }
        
        /* Navigation history buttons */
        .nav-history {
            display: inline-block;
            margin-left: 15px;
        }
        
        .nav-history button {
            padding: 5px 8px;
            font-size: 12px;
            margin: 0 2px;
        }
        
        /* Coordinate overlay */
        .coordinate-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <h1>SVG Jitter Tool - Web Version</h1>
    
    <div class="container">
        <div class="panel">
            <h2>Input SVG</h2>
            <textarea id="input-svg" placeholder="Paste your SVG code here...">&lt;svg width="200" height="200" xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;path d="M 10 10 L 190 10 L 190 190 L 10 190 Z" fill="none" stroke="black" stroke-width="2"/&gt;
  &lt;path d="M 50 50 C 100 20, 150 20, 150 50" fill="none" stroke="blue" stroke-width="2"/&gt;
  &lt;path d="M 50 100 Q 100 70, 150 100" fill="none" stroke="red" stroke-width="2"/&gt;
&lt;/svg&gt;</textarea>
        </div>
        
        <div class="panel">
            <h2>Configuration</h2>
            <div class="config-group">
                <label>
                    Jitter Amplitude: <span id="amplitude-value" class="value-display">5.0</span>
                </label>
                <input type="range" id="jitter-amplitude" min="0" max="20" step="0.1" value="5.0">
            </div>
            
            <div class="config-group">
                <label>
                    Segment Frequency: <span id="frequency-value" class="value-display">100</span>
                </label>
                <input type="range" id="segment-frequency" min="1" max="200" step="1" value="100">
            </div>
            
            <div class="config-group checkbox-group">
                <input type="checkbox" id="curvy-lines" checked>
                <label for="curvy-lines">Curvy Lines</label>
            </div>
            
            <div class="config-group">
                <button id="copy-result">Copy Jittered SVG</button>
                <button id="export-svg">Export SVG</button>
                <div id="copy-status" class="status hidden"></div>
            </div>
        </div>
    </div>
    
    <div class="panel">
        <h2>Preview</h2>
        <div class="preview-controls">
            <button id="fit-button">Fit to View</button>
            <button id="zoom-in-button">Zoom In</button>
            <button id="zoom-out-button">Zoom Out</button>
            <span id="zoom-level">100%</span>
            <div class="nav-history">
                <button id="nav-back" disabled>←</button>
                <button id="nav-forward" disabled>→</button>
            </div>
        </div>
        <div id="preview-container">
            <div class="loading" id="loading">Processing...</div>
            <div class="coordinate-overlay" id="coordinate-overlay"></div>
            <svg id="preview-svg" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <div class="drop-zone" id="drop-zone">
            <p>Drag & drop SVG file here or click to upload</p>
            <input type="file" id="file-input" accept=".svg" style="display: none;">
        </div>
        <textarea id="output-svg" placeholder="Jittered SVG will appear here..." readonly></textarea>
    </div>
    
    <div class="instructions">
        <h3>How to use:</h3>
        <ol>
            <li>Paste your SVG code in the "Input SVG" panel</li>
            <li>Adjust the jitter parameters using the sliders - preview updates automatically</li>
            <li>Set Jitter Amplitude to 0 for no effect</li>
            <li>Click "Copy Jittered SVG" to copy the result to your clipboard</li>
            <li>Use zoom controls or mouse wheel to navigate the preview</li>
            <li>Click and drag to pan around the preview</li>
        </ol>
    </div>

    <script>
        // Configuration
        const config = {
            method: "subdivision",
            jitter_amplitude: 5.0,
            segment_frequency: 100,
            curvy_lines: true
        };
        
        // Zoom and pan variables
        let currentScale = 1;
        let currentX = 0;
        let currentY = 0;
        let isDragging = false;
        let startX, startY, startPanX, startPanY;
        
        // Navigation history
        let navHistory = [];
        let navHistoryIndex = -1;
        
        // DOM Elements
        const inputSvg = document.getElementById('input-svg');
        const outputSvg = document.getElementById('output-svg');
        const previewSvg = document.getElementById('preview-svg');
        const previewContainer = document.getElementById('preview-container');
        const copyResultBtn = document.getElementById('copy-result');
        const exportSvgBtn = document.getElementById('export-svg');
        const copyStatus = document.getElementById('copy-status');
        const jitterAmplitude = document.getElementById('jitter-amplitude');
        const segmentFrequency = document.getElementById('segment-frequency');
        const curvyLines = document.getElementById('curvy-lines');
        const amplitudeValue = document.getElementById('amplitude-value');
        const frequencyValue = document.getElementById('frequency-value');
        const fitButton = document.getElementById('fit-button');
        const zoomInButton = document.getElementById('zoom-in-button');
        const zoomOutButton = document.getElementById('zoom-out-button');
        const zoomLevel = document.getElementById('zoom-level');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const loadingIndicator = document.getElementById('loading');
        const coordinateOverlay = document.getElementById('coordinate-overlay');
        const navBackBtn = document.getElementById('nav-back');
        const navForwardBtn = document.getElementById('nav-forward');
        
        // Throttling for parameter adjustments
        let throttleTimer = null;
        const throttleDelay = 50; // ms
        
        // Update value displays and apply jitter automatically
        jitterAmplitude.addEventListener('input', () => {
            amplitudeValue.textContent = jitterAmplitude.value;
            config.jitter_amplitude = parseFloat(jitterAmplitude.value);
            throttledApplyJitter();
        });
        
        segmentFrequency.addEventListener('input', () => {
            frequencyValue.textContent = segmentFrequency.value;
            config.segment_frequency = parseInt(segmentFrequency.value);
            throttledApplyJitter();
        });
        
        curvyLines.addEventListener('change', () => {
            config.curvy_lines = curvyLines.checked;
            throttledApplyJitter();
        });
        
        // Initialize values
        amplitudeValue.textContent = jitterAmplitude.value;
        frequencyValue.textContent = segmentFrequency.value;
        
        // Complex number helper
        class Complex {
            constructor(real, imag) {
                this.real = real;
                this.imag = imag;
            }
            
            add(other) {
                return new Complex(this.real + other.real, this.imag + other.imag);
            }
            
            sub(other) {
                return new Complex(this.real - other.real, this.imag - other.imag);
            }
            
            mul(scalar) {
                return new Complex(this.real * scalar, this.imag * scalar);
            }
            
            abs() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
        }
        
        // Random number generator
        function randomUniform(min, max) {
            return Math.random() * (max - min) + min;
        }
        
        // Path parsing functions
        function parsePathData(d) {
            const commands = [];
            // This regex matches SVG path commands and their arguments
            const regex = /([MmLlHhVvCcSsQqTtAaZz])\s*([^MmLlHhVvCcSsQqTtAaZz]*)/g;
            let match;
            
            while ((match = regex.exec(d)) !== null) {
                const command = match[1];
                // Split the arguments by commas or spaces, filter out empty strings, and convert to numbers
                const args = match[2].trim().split(/[\s,]+/).filter(x => x !== '').map(x => parseFloat(x));
                commands.push({ command, args });
            }
            
            return commands;
        }
        
        // Subdivision functions
        function subdivideLine(start, end, numPoints) {
            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const real = start.real + t * (end.real - start.real);
                const imag = start.imag + t * (end.imag - start.imag);
                points.push(new Complex(real, imag));
            }
            return points;
        }
        
        function jitterPoints(points, amplitude) {
            const jitteredPoints = [];
            for (const point of points) {
                // If amplitude is 0, don't apply any jitter
                if (amplitude === 0) {
                    jitteredPoints.push(point);
                } else {
                    const jitterX = randomUniform(-amplitude, amplitude);
                    const jitterY = randomUniform(-amplitude, amplitude);
                    jitteredPoints.push(new Complex(point.real + jitterX, point.imag + jitterY));
                }
            }
            return jitteredPoints;
        }
        
        // Convert points to path data
        function pointsToPathData(points, closed, curvy) {
            if (points.length < 2) return "";
            
            // If the path is closed, ensure it remains closed
            if (closed && points.length > 2) {
                points[points.length - 1] = points[0];
            }
            
            let pathData = `M ${points[0].real} ${points[0].imag}`;
            
            if (curvy && points.length > 2) {
                // Create smooth curves using cubic Bezier segments
                for (let i = 0; i < points.length - 1; i++) {
                    const start = points[i];
                    const end = points[i + 1];
                    
                    let ctrl1, ctrl2;
                    
                    if (i === 0) {
                        // First point
                        const next = (i + 2 < points.length) ? points[i + 2] : points[i + 1];
                        ctrl1 = start.add(end.sub(start).mul(0.3));
                        ctrl2 = end.sub(next.sub(start).mul(0.3));
                    } else if (i === points.length - 2) {
                        // Last segment
                        const prev = points[i - 1];
                        ctrl1 = start.add(end.sub(prev).mul(0.3));
                        ctrl2 = end.sub(end.sub(start).mul(0.3));
                    } else {
                        // Middle segments
                        const prev = points[i - 1];
                        const next = points[i + 2];
                        ctrl1 = start.add(end.sub(prev).mul(0.3));
                        ctrl2 = end.sub(next.sub(start).mul(0.3));
                    }
                    
                    pathData += ` C ${ctrl1.real.toFixed(2)} ${ctrl1.imag.toFixed(2)} ${ctrl2.real.toFixed(2)} ${ctrl2.imag.toFixed(2)} ${end.real.toFixed(2)} ${end.imag.toFixed(2)}`;
                }
            } else {
                // Create straight line segments
                for (let i = 1; i < points.length; i++) {
                    pathData += ` L ${points[i].real.toFixed(2)} ${points[i].imag.toFixed(2)}`;
                }
            }
            
            if (closed) {
                pathData += " Z";
            }
            
            return pathData;
        }
        
        // Process a single path
        function processPath(d) {
            const commands = parsePathData(d);
            if (commands.length === 0) return d;
            
            // Check if path is closed
            const isClosed = commands.some(cmd => cmd.command === 'Z' || cmd.command === 'z');
            
            // If jitter amplitude is 0, return the original path data
            if (config.jitter_amplitude === 0) {
                return d;
            }
            
            // Collect all points from the path
            let allPoints = [];
            let currentPoint = new Complex(0, 0);
            let startPoint = new Complex(0, 0);
            
            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];
                const args = cmd.args;
                
                switch (cmd.command) {
                    case 'M':
                        currentPoint = new Complex(args[0], args[1]);
                        startPoint = new Complex(args[0], args[1]);
                        if (allPoints.length === 0) {
                            allPoints.push(currentPoint);
                        }
                        break;
                    case 'm':
                        currentPoint = new Complex(currentPoint.real + args[0], currentPoint.imag + args[1]);
                        startPoint = new Complex(currentPoint.real, currentPoint.imag);
                        if (allPoints.length === 0) {
                            allPoints.push(currentPoint);
                        }
                        break;
                    case 'L':
                        {
                            const start = currentPoint;
                            const end = new Complex(args[0], args[1]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            const frequency = config.curvy_lines ? config.segment_frequency / 2 : config.segment_frequency;
                            const numPoints = Math.max(2, Math.floor(length / frequency));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'l':
                        {
                            const start = currentPoint;
                            const end = new Complex(currentPoint.real + args[0], currentPoint.imag + args[1]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            const frequency = config.curvy_lines ? config.segment_frequency / 2 : config.segment_frequency;
                            const numPoints = Math.max(2, Math.floor(length / frequency));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'C':
                        {
                            // For simplicity, we'll treat cubic Bezier as a line from start to end
                            // In a full implementation, we would properly subdivide the Bezier curve
                            const start = currentPoint;
                            const end = new Complex(args[4], args[5]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            const frequency = config.curvy_lines ? config.segment_frequency / 2 : config.segment_frequency;
                            const numPoints = Math.max(2, Math.floor(length / frequency));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'c':
                        {
                            // For simplicity, we'll treat cubic Bezier as a line from start to end
                            const start = currentPoint;
                            const end = new Complex(currentPoint.real + args[4], currentPoint.imag + args[5]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            const frequency = config.curvy_lines ? config.segment_frequency / 2 : config.segment_frequency;
                            const numPoints = Math.max(2, Math.floor(length / frequency));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'Q':
                        {
                            // For simplicity, we'll treat quadratic Bezier as a line from start to end
                            const start = currentPoint;
                            const end = new Complex(args[2], args[3]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            const frequency = config.curvy_lines ? config.segment_frequency / 2 : config.segment_frequency;
                            const numPoints = Math.max(2, Math.floor(length / frequency));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'q':
                        {
                            // For simplicity, we'll treat quadratic Bezier as a line from start to end
                            const start = currentPoint;
                            const end = new Complex(currentPoint.real + args[2], currentPoint.imag + args[3]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            const frequency = config.curvy_lines ? config.segment_frequency / 2 : config.segment_frequency;
                            const numPoints = Math.max(2, Math.floor(length / frequency));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'Z':
                    case 'z':
                        currentPoint = startPoint;
                        break;
                }
            }
            
            // Apply jitter to all points
            const jitteredPoints = jitterPoints(allPoints, config.jitter_amplitude);
            
            // Convert back to path data
            return pointsToPathData(jitteredPoints, isClosed, config.curvy_lines);
        }
        
        // Process all paths in SVG
        function processSvgPaths(svgContent) {
            // Create a temporary div to parse the SVG
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgContent, 'image/svg+xml');
            const svgElement = doc.documentElement;
            
            if (!svgElement || svgElement.tagName !== 'svg') {
                // If parsing failed, return original content
                return svgContent;
            }
            
            // Store original SVG attributes
            const originalAttributes = {};
            for (let i = 0; i < svgElement.attributes.length; i++) {
                const attr = svgElement.attributes[i];
                originalAttributes[attr.name] = attr.value;
            }
            
            // Process all path elements
            const paths = svgElement.querySelectorAll('path');
            paths.forEach(path => {
                const d = path.getAttribute('d');
                if (d) {
                    const jitteredD = processPath(d);
                    path.setAttribute('d', jitteredD);
                }
            });
            
            // Restore original SVG attributes to ensure proper rendering
            for (const [name, value] of Object.entries(originalAttributes)) {
                svgElement.setAttribute(name, value);
            }
            
            // Serialize the modified SVG back to string
            const serializer = new XMLSerializer();
            return serializer.serializeToString(svgElement);
        }
        
        // Apply jitter to SVG with improved rendering lifecycle handling
        function applyJitter() {
            const input = inputSvg.value;
            if (!input) {
                alert('Please paste SVG code first');
                return;
            }
            
            try {
                // Show loading indicator
                loadingIndicator.style.display = 'block';
                
                // Process SVG asynchronously to prevent UI blocking
                setTimeout(() => {
                    try {
                        const jitteredSvg = processSvgPaths(input);
                        outputSvg.value = jitteredSvg;
                        
                        // Update preview with proper SVG handling
                        updatePreview(jitteredSvg);
                        
                        // Add to navigation history
                        addToHistory({
                            scale: currentScale,
                            x: currentX,
                            y: currentY
                        });
                        
                        // Show success message
                        showStatus('Jitter applied successfully!', 'success');
                    } catch (error) {
                        console.error('Error applying jitter:', error);
                        showStatus(`Error: ${error.message}`, 'error');
                    } finally {
                        // Hide loading indicator
                        loadingIndicator.style.display = 'none';
                    }
                }, 10);
            } catch (error) {
                console.error('Error applying jitter:', error);
                showStatus(`Error: ${error.message}`, 'error');
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Throttled version of applyJitter
        function throttledApplyJitter() {
            if (throttleTimer) {
                clearTimeout(throttleTimer);
            }
            throttleTimer = setTimeout(() => {
                applyJitter();
                throttleTimer = null;
            }, throttleDelay);
        }
        
        // Update preview with proper SVG handling and coordinate system preservation
        function updatePreview(svgContent) {
            // Clear container
            previewContainer.innerHTML = '';
            
            // Add loading indicator and coordinate overlay back
            previewContainer.appendChild(loadingIndicator);
            previewContainer.appendChild(coordinateOverlay);
            
            // Create a new SVG element
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = svgContent;
            const newSvg = tempDiv.querySelector('svg');
            
            if (newSvg) {
                // Preserve original viewBox if it exists, otherwise create one
                const originalViewBox = newSvg.getAttribute('viewBox');
                const originalWidth = newSvg.getAttribute('width');
                const originalHeight = newSvg.getAttribute('height');
                
                // Handle viewBox with a more comprehensive approach
                if (!originalViewBox) {
                    // Try to determine appropriate viewBox based on content
                    let viewBox = '0 0 200 200'; // Default fallback
                    
                    if (originalWidth && originalHeight) {
                        // Use original dimensions
                        const width = parseFloat(originalWidth) || 200;
                        const height = parseFloat(originalHeight) || 200;
                        viewBox = `0 0 ${width} ${height}`;
                    } else {
                        // Try to get bounding box of content
                        try {
                            // Temporarily add to DOM to get bbox
                            previewContainer.appendChild(newSvg);
                            const bbox = newSvg.getBBox();
                            previewContainer.removeChild(newSvg);
                            
                            if (bbox.width > 0 && bbox.height > 0) {
                                // Add padding to ensure content isn't cut off
                                const padding = 20;
                                viewBox = `${bbox.x - padding} ${bbox.y - padding} ${bbox.width + padding * 2} ${bbox.height + padding * 2}`;
                            }
                        } catch (e) {
                            console.log('Could not determine content bounds');
                        }
                    }
                    
                    newSvg.setAttribute('viewBox', viewBox);
                }
                
                // Ensure preserveAspectRatio is set for proper scaling
                newSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                
                // Apply CSS to make it fill the container
                newSvg.style.width = '100%';
                newSvg.style.height = '100%';
                
                // Add vector-effect to all graphical elements to prevent stroke scaling
                const graphicalElements = newSvg.querySelectorAll('path, line, circle, rect, polygon, polyline');
                graphicalElements.forEach(element => {
                    element.style.vectorEffect = 'non-scaling-stroke';
                });
                
                // Add to container
                previewContainer.appendChild(newSvg);
                
                // Use MutationObserver to detect when SVG is fully rendered
                const observer = new MutationObserver(() => {
                    // Once the SVG is in the DOM, fit to view
                    setTimeout(() => {
                        fitToView();
                    }, 50);
                });
                
                observer.observe(newSvg, { childList: true, subtree: true });
                
                // Also trigger fit after a short delay as fallback
                setTimeout(() => {
                    fitToView();
                    observer.disconnect();
                }, 500);
            }
        }
        
        // Copy result to clipboard
        function copyResult() {
            if (!outputSvg.value) {
                showStatus('No jittered SVG to copy', 'error');
                return;
            }
            
            navigator.clipboard.writeText(outputSvg.value)
                .then(() => {
                    showStatus('Copied to clipboard!', 'success');
                })
                .catch(err => {
                    showStatus(`Failed to copy: ${err.message}`, 'error');
                });
        }
        
        // Export SVG to file
        function exportSvg() {
            if (!outputSvg.value) {
                showStatus('No jittered SVG to export', 'error');
                return;
            }
            
            const blob = new Blob([outputSvg.value], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'jittered-svg.svg';
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus('SVG exported successfully!', 'success');
            }, 100);
        }
        
        // Zoom and pan functions with proper coordinate system handling
        function updateTransform() {
            const svgElement = previewContainer.querySelector('svg');
            if (svgElement) {
                // Use CSS transform with proper transform-origin
                svgElement.style.transform = `translate(${currentX}px, ${currentY}px) scale(${currentScale})`;
                svgElement.style.transformOrigin = '0 0';
                svgElement.style.willChange = 'transform'; // Optimize for performance
                zoomLevel.textContent = `${Math.round(currentScale * 100)}%`;
            }
        }
        
        // Improved fitToView with better error handling and coordinate system preservation
        function fitToView() {
            const svgElement = previewContainer.querySelector('svg');
            if (svgElement) {
                try {
                    // Get the viewBox dimensions
                    const viewBoxAttr = svgElement.getAttribute('viewBox');
                    if (viewBoxAttr) {
                        const viewBoxValues = viewBoxAttr.split(' ').map(Number);
                        if (viewBoxValues.length === 4) {
                            const [viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight] = viewBoxValues;
                            
                            // Get container dimensions
                            const containerWidth = previewContainer.clientWidth;
                            const containerHeight = previewContainer.clientHeight;
                            
                            // Calculate scale to fit
                            const scaleX = containerWidth / viewBoxWidth;
                            const scaleY = containerHeight / viewBoxHeight;
                            currentScale = Math.min(scaleX, scaleY) * 0.9; // 90% to add some padding
                            
                            // Center the content
                            currentX = (containerWidth - viewBoxWidth * currentScale) / 2 - viewBoxX * currentScale;
                            currentY = (containerHeight - viewBoxHeight * currentScale) / 2 - viewBoxY * currentScale;
                        }
                    } else {
                        // Fallback to getBBox if no viewBox
                        const bbox = svgElement.getBBox();
                        if (bbox.width > 0 && bbox.height > 0) {
                            // Get container dimensions
                            const containerWidth = previewContainer.clientWidth;
                            const containerHeight = previewContainer.clientHeight;
                            
                            // Calculate scale to fit
                            const scaleX = containerWidth / bbox.width;
                            const scaleY = containerHeight / bbox.height;
                            currentScale = Math.min(scaleX, scaleY) * 0.9; // 90% to add some padding
                            
                            // Center the content
                            currentX = (containerWidth - bbox.width * currentScale) / 2 - bbox.x * currentScale;
                            currentY = (containerHeight - bbox.height * currentScale) / 2 - bbox.y * currentScale;
                        }
                    }
                } catch (e) {
                    console.log('Error in fitToView:', e);
                    // Fallback to default
                    currentScale = 1;
                    currentX = 0;
                    currentY = 0;
                }
            } else {
                // Fallback to default
                currentScale = 1;
                currentX = 0;
                currentY = 0;
            }
            updateTransform();
        }
        
        function zoom(factor) {
            currentScale *= factor;
            // Limit zoom levels
            currentScale = Math.min(Math.max(0.1, currentScale), 10);
            updateTransform();
            
            // Add to navigation history
            addToHistory({
                scale: currentScale,
                x: currentX,
                y: currentY
            });
        }
        
        function startDrag(e) {
            if (e.target.closest('svg')) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startPanX = currentX;
                startPanY = currentY;
                previewContainer.style.cursor = 'grabbing';
                e.preventDefault();
            }
        }
        
        function drag(e) {
            if (isDragging) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                currentX = startPanX + dx;
                currentY = startPanY + dy;
                updateTransform();
            }
        }
        
        function endDrag() {
            if (isDragging) {
                isDragging = false;
                previewContainer.style.cursor = 'grab';
                
                // Add to navigation history
                addToHistory({
                    scale: currentScale,
                    x: currentX,
                    y: currentY
                });
            }
        }
        
        function handleWheel(e) {
            const zoomIntensity = 0.1;
            const wheel = e.deltaY < 0 ? 1 : -1;
            const zoomFactor = 1 + wheel * zoomIntensity;
            
            // Get mouse position relative to container
            const rect = previewContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Apply zoom
            const oldScale = currentScale;
            currentScale *= zoomFactor;
            currentScale = Math.min(Math.max(0.1, currentScale), 10);
            
            // Adjust pan to zoom towards mouse position
            currentX = mouseX - (mouseX - currentX) * (currentScale / oldScale);
            currentY = mouseY - (mouseY - currentY) * (currentScale / oldScale);
            
            updateTransform();
            e.preventDefault();
            
            // Add to navigation history
            addToHistory({
                scale: currentScale,
                x: currentX,
                y: currentY
            });
        }
        
        // Navigation history functions
        function addToHistory(state) {
            // Remove any forward history if we're not at the end
            if (navHistoryIndex < navHistory.length - 1) {
                navHistory = navHistory.slice(0, navHistoryIndex + 1);
            }
            
            // Add new state
            navHistory.push({
                scale: state.scale,
                x: state.x,
                y: state.y
            });
            
            // Limit history size
            if (navHistory.length > 50) {
                navHistory.shift();
            } else {
                navHistoryIndex = navHistory.length - 1;
            }
            
            // Update button states
            updateNavButtons();
        }
        
        function navigateBack() {
            if (navHistoryIndex > 0) {
                navHistoryIndex--;
                const state = navHistory[navHistoryIndex];
                currentScale = state.scale;
                currentX = state.x;
                currentY = state.y;
                updateTransform();
                updateNavButtons();
            }
        }
        
        function navigateForward() {
            if (navHistoryIndex < navHistory.length - 1) {
                navHistoryIndex++;
                const state = navHistory[navHistoryIndex];
                currentScale = state.scale;
                currentX = state.x;
                currentY = state.y;
                updateTransform();
                updateNavButtons();
            }
        }
        
        function updateNavButtons() {
            navBackBtn.disabled = navHistoryIndex <= 0;
            navForwardBtn.disabled = navHistoryIndex >= navHistory.length - 1;
        }
        
        // Coordinate overlay
        function updateCoordinateOverlay(e) {
            const rect = previewContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert screen coordinates to SVG coordinates
            const svgElement = previewContainer.querySelector('svg');
            if (svgElement) {
                const viewBoxAttr = svgElement.getAttribute('viewBox');
                if (viewBoxAttr) {
                    const viewBoxValues = viewBoxAttr.split(' ').map(Number);
                    if (viewBoxValues.length === 4) {
                        const [viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight] = viewBoxValues;
                        
                        // Calculate SVG coordinates
                        const svgX = viewBoxX + (x - currentX) / currentScale;
                        const svgY = viewBoxY + (y - currentY) / currentScale;
                        
                        coordinateOverlay.textContent = `X: ${svgX.toFixed(1)}, Y: ${svgY.toFixed(1)}`;
                        coordinateOverlay.style.display = 'block';
                    }
                }
            }
        }
        
        // Drag and drop functions
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            dropZone.style.backgroundColor = '#e9e9e9';
        }
        
        function handleDrop(e) {
            e.preventDefault();
            dropZone.style.backgroundColor = '#f9f9f9';
            
            const files = e.dataTransfer.files;
            if (files.length) {
                handleFile(files[0]);
            }
        }
        
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length) {
                handleFile(files[0]);
            }
        }
        
        function handleFile(file) {
            if (file.type !== 'image/svg+xml' && !file.name.endsWith('.svg')) {
                alert('Please select an SVG file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                inputSvg.value = e.target.result;
                applyJitter();
            };
            reader.readAsText(file);
        }
        
        // Show status message
        function showStatus(message, type) {
            copyStatus.textContent = message;
            copyStatus.className = `status ${type}`;
            copyStatus.classList.remove('hidden');
            
            // Hide after 3 seconds
            setTimeout(() => {
                copyStatus.classList.add('hidden');
            }, 3000);
        }
        
        // Initialize event listeners
        function initEventListeners() {
            // Update value displays and apply jitter automatically
            jitterAmplitude.addEventListener('input', () => {
                amplitudeValue.textContent = jitterAmplitude.value;
                config.jitter_amplitude = parseFloat(jitterAmplitude.value);
                throttledApplyJitter();
            });
            
            segmentFrequency.addEventListener('input', () => {
                frequencyValue.textContent = segmentFrequency.value;
                config.segment_frequency = parseInt(segmentFrequency.value);
                throttledApplyJitter();
            });
            
            curvyLines.addEventListener('change', () => {
                config.curvy_lines = curvyLines.checked;
                throttledApplyJitter();
            });
            
            // Update when input SVG changes
            inputSvg.addEventListener('input', () => {
                throttledApplyJitter();
            });
            
            // Copy result button
            copyResultBtn.addEventListener('click', copyResult);
            
            // Export SVG button
            exportSvgBtn.addEventListener('click', exportSvg);
            
            // Zoom and fit buttons
            fitButton.addEventListener('click', fitToView);
            zoomInButton.addEventListener('click', () => zoom(1.2));
            zoomOutButton.addEventListener('click', () => zoom(0.8));
            
            // Navigation history buttons
            navBackBtn.addEventListener('click', navigateBack);
            navForwardBtn.addEventListener('click', navigateForward);
            
            // Drag and drop functionality
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('drop', handleDrop);
            
            // Pan functionality
            previewContainer.addEventListener('mousedown', startDrag);
            previewContainer.addEventListener('mousemove', drag);
            previewContainer.addEventListener('mouseup', endDrag);
            previewContainer.addEventListener('mouseleave', endDrag);
            previewContainer.addEventListener('wheel', handleWheel);
            
            // Coordinate overlay
            previewContainer.addEventListener('mousemove', updateCoordinateOverlay);
            previewContainer.addEventListener('mouseleave', () => {
                coordinateOverlay.style.display = 'none';
            });
        }
        
        // Initialize with sample SVG
        window.addEventListener('load', () => {
            // Initialize event listeners
            initEventListeners();
            
            // Small delay to ensure DOM is fully loaded
            setTimeout(() => {
                applyJitter();
            }, 100);
        });
    </script>
</body>
</html>