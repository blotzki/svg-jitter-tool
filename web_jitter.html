<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Jitter Tool - Web Version</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --text-color: #333;
            --panel-bg: white;
            --panel-border: #ddd;
            --heading-color: #555;
            --input-border: #ddd;
            --button-bg: #4CAF50;
            --button-hover: #45a049;
            --button-disabled: #cccccc;
            --instructions-bg: #e3f2fd;
            --instructions-border: #2196F3;
            --success-bg: #d4edda;
            --success-text: #155724;
            --success-border: #c3e6cb;
            --error-bg: #f8d7da;
            --error-text: #721c24;
            --error-border: #f5c6cb;
            --drop-zone-bg: #f9f9f9;
            --drop-zone-hover: #f0f0f0;
            --drop-zone-border: #ccc;
            --loading-color: #666;
            --coordinate-overlay-bg: rgba(0, 0, 0, 0.7);
        }
        
        .dark-mode {
            --bg-color: #1e1e1e;
            --text-color: #e0e0e0;
            --panel-bg: #2d2d30;
            --panel-border: #3f3f46;
            --heading-color: #e0e0e0;
            --input-border: #3f3f46;
            --button-bg: #107c10;
            --button-hover: #0d6b0d;
            --button-disabled: #555555;
            --instructions-bg: #1a365d;
            --instructions-border: #2b6cb0;
            --success-bg: #224a22;
            --success-text: #a0d9a0;
            --success-border: #3b8c3b;
            --error-bg: #5c1f1f;
            --error-text: #f0a0a0;
            --error-border: #a33d3d;
            --drop-zone-bg: #252526;
            --drop-zone-hover: #2a2a2c;
            --drop-zone-border: #555;
            --loading-color: #aaa;
            --coordinate-overlay-bg: rgba(255, 255, 255, 0.9);
        }
        
        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        
        h1 {
            color: var(--text-color);
            text-align: center;
            font-weight: 600;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            border: 1px solid var(--panel-border);
        }
        
        h2 {
            margin-top: 0;
            color: var(--heading-color);
            border-bottom: 2px solid var(--panel-border);
            padding-bottom: 10px;
            font-weight: 600;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            resize: vertical;
            background-color: var(--panel-bg);
            color: var(--text-color);
        }
        
        .config-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .value-display {
            display: inline-block;
            width: 50px;
            text-align: right;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: bold;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
        }
        
        .checkbox-group input {
            margin-right: 8px;
        }
        
        button {
            background-color: var(--button-bg);
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 500;
        }
        
        button:hover {
            background-color: var(--button-hover);
        }
        
        button:disabled {
            background-color: var(--button-disabled);
            cursor: not-allowed;
        }
        
        #preview-container {
            position: relative;
            min-height: 300px;
            height: 400px;
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            background: var(--panel-bg);
            overflow: hidden;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #preview-container svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .instructions {
            background: var(--instructions-bg);
            border-left: 4px solid var(--instructions-border);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .success {
            background-color: var(--success-bg);
            color: var(--success-text);
            border: 1px solid var(--success-border);
        }
        
        .error {
            background-color: var(--error-bg);
            color: var(--error-text);
            border: 1px solid var(--error-border);
        }
        
        .hidden {
            display: none;
        }
        
        .drop-zone {
            border: 2px dashed var(--drop-zone-border);
            border-radius: 4px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
            background-color: var(--drop-zone-bg);
        }
        
        .drop-zone:hover {
            background-color: var(--drop-zone-hover);
        }
        
        .drop-zone p {
            margin: 0;
            color: var(--text-color);
        }
        
        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: var(--loading-color);
        }
        
        /* Coordinate overlay */
        .coordinate-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: var(--coordinate-overlay-bg);
            color: var(--text-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }
        
        /* Dark mode toggle */
        .dark-mode-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .dark-mode-toggle:hover {
            background: var(--button-bg);
        }
    </style>
</head>
<body>
    <div class="dark-mode-toggle" id="dark-mode-toggle">ðŸŒ™</div>
    <h1>SVG Jitter Tool - Web Version</h1>
    
    <div class="container">
        <div class="panel">
            <h2>Input SVG</h2>
            <textarea id="input-svg" placeholder="Paste your SVG code here...">&lt;svg width="200" height="200" xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;path d="M 10 10 L 190 10 L 190 190 L 10 190 Z" fill="none" stroke="black" stroke-width="2"/&gt;
  &lt;path d="M 50 50 C 100 20, 150 20, 150 50" fill="none" stroke="blue" stroke-width="2"/&gt;
  &lt;path d="M 50 100 Q 100 70, 150 100" fill="none" stroke="red" stroke-width="2"/&gt;
&lt;/svg&gt;</textarea>
        </div>
        
        <div class="panel">
            <h2>Configuration</h2>
            <div class="config-group">
                <label>
                    Jitter Amplitude: <span id="amplitude-value" class="value-display">5.0</span>
                </label>
                <input type="range" id="jitter-amplitude" min="0" max="20" step="0.1" value="5.0">
            </div>
            
            <div class="config-group">
                <label>
                    Segment Frequency: <span id="frequency-value" class="value-display">50</span>
                </label>
                <input type="range" id="segment-frequency" min="0" max="100" step="1" value="50">
            </div>
            
            <div class="config-group checkbox-group">
                <input type="checkbox" id="curvy-lines" checked>
                <label for="curvy-lines">Curvy Lines</label>
            </div>
            
            <div class="config-group">
                <button id="copy-result">Copy Jittered SVG</button>
                <button id="export-svg">Export SVG</button>
                <div id="copy-status" class="status hidden"></div>
            </div>
        </div>
    </div>
    
    <div class="panel">
        <h2>Preview</h2>
        <div id="preview-container">
            <div class="loading" id="loading">Processing...</div>
            <div class="coordinate-overlay" id="coordinate-overlay"></div>
            <svg id="preview-svg" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <div class="drop-zone" id="drop-zone">
            <p>Drag & drop SVG file here or click to upload</p>
            <input type="file" id="file-input" accept=".svg" style="display: none;">
        </div>
        <textarea id="output-svg" placeholder="Jittered SVG will appear here..." readonly></textarea>
    </div>
    
    <div class="instructions">
        <h3>How to use:</h3>
        <ol>
            <li>Paste your SVG code in the "Input SVG" panel</li>
            <li>Adjust the jitter parameters using the sliders - preview updates automatically</li>
            <li>Set Jitter Amplitude to 0 for no effect</li>
            <li>Click "Copy Jittered SVG" to copy the result to your clipboard</li>
            <li>Use the drag & drop area to load SVG files</li>
        </ol>
    </div>

    <script>
        // Configuration
        const config = {
            method: "subdivision",
            jitter_amplitude: 5.0,
            segment_frequency: 100,
            curvy_lines: true
        };
        
        // Preview variables
        let isDragging = false;
        let startX, startY, startPanX, startPanY;
        
        // DOM Elements
        const inputSvg = document.getElementById('input-svg');
        const outputSvg = document.getElementById('output-svg');
        const previewSvg = document.getElementById('preview-svg');
        const previewContainer = document.getElementById('preview-container');
        const copyResultBtn = document.getElementById('copy-result');
        const exportSvgBtn = document.getElementById('export-svg');
        const copyStatus = document.getElementById('copy-status');
        const jitterAmplitude = document.getElementById('jitter-amplitude');
        const segmentFrequency = document.getElementById('segment-frequency');
        const curvyLines = document.getElementById('curvy-lines');
        const amplitudeValue = document.getElementById('amplitude-value');
        const frequencyValue = document.getElementById('frequency-value');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const loadingIndicator = document.getElementById('loading');
        const coordinateOverlay = document.getElementById('coordinate-overlay');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        
        // Throttling for parameter adjustments
        let throttleTimer = null;
        const throttleDelay = 50; // ms
        
        // Update value displays and apply jitter automatically
        jitterAmplitude.addEventListener('input', () => {
            amplitudeValue.textContent = jitterAmplitude.value;
            config.jitter_amplitude = parseFloat(jitterAmplitude.value);
            throttledApplyJitter();
        });
        
        segmentFrequency.addEventListener('input', () => {
            frequencyValue.textContent = parseInt(segmentFrequency.value);
            config.segment_frequency = parseInt(segmentFrequency.value);
            throttledApplyJitter();
        });
        
        curvyLines.addEventListener('change', () => {
            config.curvy_lines = curvyLines.checked;
            throttledApplyJitter();
        });
        
        // Initialize values
        amplitudeValue.textContent = jitterAmplitude.value;
        frequencyValue.textContent = parseInt(segmentFrequency.value);
        
        // Complex number helper
        class Complex {
            constructor(real, imag) {
                this.real = real;
                this.imag = imag;
            }
            
            add(other) {
                return new Complex(this.real + other.real, this.imag + other.imag);
            }
            
            sub(other) {
                return new Complex(this.real - other.real, this.imag - other.imag);
            }
            
            mul(scalar) {
                return new Complex(this.real * scalar, this.imag * scalar);
            }
            
            abs() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
        }
        
        // Random number generator
        function randomUniform(min, max) {
            return Math.random() * (max - min) + min;
        }
        
        // Path parsing functions
        function parsePathData(d) {
            const commands = [];
            // This regex matches SVG path commands and their arguments
            const regex = /([MmLlHhVvCcSsQqTtAaZz])\s*([^MmLlHhVvCcSsQqTtAaZz]*)/g;
            let match;
            
            while ((match = regex.exec(d)) !== null) {
                const command = match[1];
                // Split the arguments by commas or spaces, filter out empty strings, and convert to numbers
                const args = match[2].trim().split(/[\s,]+/).filter(x => x !== '').map(x => parseFloat(x));
                commands.push({ command, args });
            }
            
            return commands;
        }
        
        // Subdivision functions
        function subdivideLine(start, end, numPoints) {
            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const real = start.real + t * (end.real - start.real);
                const imag = start.imag + t * (end.imag - start.imag);
                points.push(new Complex(real, imag));
            }
            return points;
        }
        
        function jitterPoints(points, amplitude) {
            const jitteredPoints = [];
            for (const point of points) {
                // If amplitude is 0, don't apply any jitter
                if (amplitude === 0) {
                    jitteredPoints.push(point);
                } else {
                    const jitterX = randomUniform(-amplitude, amplitude);
                    const jitterY = randomUniform(-amplitude, amplitude);
                    jitteredPoints.push(new Complex(point.real + jitterX, point.imag + jitterY));
                }
            }
            return jitteredPoints;
        }
        
        // Convert points to path data
        function pointsToPathData(points, closed, curvy) {
            if (points.length < 2) return "";
            
            // If the path is closed, ensure it remains closed
            if (closed && points.length > 2) {
                points[points.length - 1] = points[0];
            }
            
            let pathData = `M ${points[0].real} ${points[0].imag}`;
            
            if (curvy && points.length > 2) {
                // Create smooth curves using cubic Bezier segments
                for (let i = 0; i < points.length - 1; i++) {
                    const start = points[i];
                    const end = points[i + 1];
                    
                    let ctrl1, ctrl2;
                    
                    if (i === 0) {
                        // First point
                        const next = (i + 2 < points.length) ? points[i + 2] : points[i + 1];
                        ctrl1 = start.add(end.sub(start).mul(0.3));
                        ctrl2 = end.sub(next.sub(start).mul(0.3));
                    } else if (i === points.length - 2) {
                        // Last segment
                        const prev = points[i - 1];
                        ctrl1 = start.add(end.sub(prev).mul(0.3));
                        ctrl2 = end.sub(end.sub(start).mul(0.3));
                    } else {
                        // Middle segments
                        const prev = points[i - 1];
                        const next = points[i + 2];
                        ctrl1 = start.add(end.sub(prev).mul(0.3));
                        ctrl2 = end.sub(next.sub(start).mul(0.3));
                    }
                    
                    pathData += ` C ${ctrl1.real.toFixed(2)} ${ctrl1.imag.toFixed(2)} ${ctrl2.real.toFixed(2)} ${ctrl2.imag.toFixed(2)} ${end.real.toFixed(2)} ${end.imag.toFixed(2)}`;
                }
            } else {
                // Create straight line segments
                for (let i = 1; i < points.length; i++) {
                    pathData += ` L ${points[i].real.toFixed(2)} ${points[i].imag.toFixed(2)}`;
                }
            }
            
            if (closed) {
                pathData += " Z";
            }
            
            return pathData;
        }
        
        // Process a single path
        function processPath(d) {
            const commands = parsePathData(d);
            if (commands.length === 0) return d;
            
            // Check if path is closed
            const isClosed = commands.some(cmd => cmd.command === 'Z' || cmd.command === 'z');
            
            // If jitter amplitude is 0, return the original path data
            if (config.jitter_amplitude === 0) {
                return d;
            }
            
            // Collect all points from the path
            let allPoints = [];
            let currentPoint = new Complex(0, 0);
            let startPoint = new Complex(0, 0);
            
            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];
                const args = cmd.args;
                
                switch (cmd.command) {
                    case 'M':
                        currentPoint = new Complex(args[0], args[1]);
                        startPoint = new Complex(args[0], args[1]);
                        if (allPoints.length === 0) {
                            allPoints.push(currentPoint);
                        }
                        break;
                    case 'm':
                        currentPoint = new Complex(currentPoint.real + args[0], currentPoint.imag + args[1]);
                        startPoint = new Complex(currentPoint.real, currentPoint.imag);
                        if (allPoints.length === 0) {
                            allPoints.push(currentPoint);
                        }
                        break;
                    case 'L':
                        {
                            const start = currentPoint;
                            const end = new Complex(args[0], args[1]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            // Convert frequency from 0-100 scale to a subdivision factor
                            // 0 = no subdivisions, 100 = maximum subdivisions
                            const subdivisionFactor = (config.segment_frequency / 100) * 0.5; // Scale to 0-0.5 range for less extreme effect
                            const numPoints = Math.max(2, Math.floor(length * subdivisionFactor));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'l':
                        {
                            const start = currentPoint;
                            const end = new Complex(currentPoint.real + args[0], currentPoint.imag + args[1]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            // Convert frequency from 0-100 scale to a subdivision factor
                            // 0 = no subdivisions, 100 = maximum subdivisions
                            const subdivisionFactor = (config.segment_frequency / 100) * 0.5; // Scale to 0-0.5 range for less extreme effect
                            const numPoints = Math.max(2, Math.floor(length * subdivisionFactor));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'C':
                        {
                            // For simplicity, we'll treat cubic Bezier as a line from start to end
                            // In a full implementation, we would properly subdivide the Bezier curve
                            const start = currentPoint;
                            const end = new Complex(args[4], args[5]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            // Convert frequency from 0-100 scale to a subdivision factor
                            // 0 = no subdivisions, 100 = maximum subdivisions
                            const subdivisionFactor = (config.segment_frequency / 100) * 0.5; // Scale to 0-0.5 range for less extreme effect
                            const numPoints = Math.max(2, Math.floor(length * subdivisionFactor));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'c':
                        {
                            // For simplicity, we'll treat cubic Bezier as a line from start to end
                            const start = currentPoint;
                            const end = new Complex(currentPoint.real + args[4], currentPoint.imag + args[5]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            // Convert frequency from 0-100 scale to a subdivision factor
                            // 0 = no subdivisions, 100 = maximum subdivisions
                            const subdivisionFactor = (config.segment_frequency / 100) * 0.5; // Scale to 0-0.5 range for less extreme effect
                            const numPoints = Math.max(2, Math.floor(length * subdivisionFactor));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'Q':
                        {
                            // For simplicity, we'll treat quadratic Bezier as a line from start to end
                            const start = currentPoint;
                            const end = new Complex(args[2], args[3]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            // Convert frequency from 0-100 scale to a subdivision factor
                            // 0 = no subdivisions, 100 = maximum subdivisions
                            const subdivisionFactor = (config.segment_frequency / 100) * 0.5; // Scale to 0-0.5 range for less extreme effect
                            const numPoints = Math.max(2, Math.floor(length * subdivisionFactor));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'q':
                        {
                            // For simplicity, we'll treat quadratic Bezier as a line from start to end
                            const start = currentPoint;
                            const end = new Complex(currentPoint.real + args[2], currentPoint.imag + args[3]);
                            currentPoint = end;
                            
                            // Calculate number of subdivisions
                            const length = end.sub(start).abs();
                            // Convert frequency from 0-100 scale to a subdivision factor
                            // 0 = no subdivisions, 100 = maximum subdivisions
                            const subdivisionFactor = (config.segment_frequency / 100) * 0.5; // Scale to 0-0.5 range for less extreme effect
                            const numPoints = Math.max(2, Math.floor(length * subdivisionFactor));
                            
                            // Subdivide the line
                            const points = subdivideLine(start, end, numPoints);
                            
                            if (allPoints.length === 0) {
                                allPoints = points;
                            } else {
                                // For subsequent segments, skip the first point
                                allPoints = allPoints.concat(points.slice(1));
                            }
                        }
                        break;
                    case 'Z':
                    case 'z':
                        currentPoint = startPoint;
                        break;
                }
            }
            
            // Apply jitter to all points
            const jitteredPoints = jitterPoints(allPoints, config.jitter_amplitude);
            
            // Convert back to path data
            return pointsToPathData(jitteredPoints, isClosed, config.curvy_lines);
        }
        
        // Process all paths in SVG
        function processSvgPaths(svgContent) {
            // Create a temporary div to parse the SVG
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgContent, 'image/svg+xml');
            const svgElement = doc.documentElement;
            
            if (!svgElement || svgElement.tagName !== 'svg') {
                // If parsing failed, return original content
                return svgContent;
            }
            
            // Store original SVG attributes
            const originalAttributes = {};
            for (let i = 0; i < svgElement.attributes.length; i++) {
                const attr = svgElement.attributes[i];
                originalAttributes[attr.name] = attr.value;
            }
            
            // Process all path elements
            const paths = svgElement.querySelectorAll('path');
            paths.forEach(path => {
                const d = path.getAttribute('d');
                if (d) {
                    const jitteredD = processPath(d);
                    path.setAttribute('d', jitteredD);
                }
            });
            
            // Restore original SVG attributes to ensure proper rendering
            for (const [name, value] of Object.entries(originalAttributes)) {
                svgElement.setAttribute(name, value);
            }
            
            // Serialize the modified SVG back to string
            const serializer = new XMLSerializer();
            return serializer.serializeToString(svgElement);
        }
        
        // Apply jitter to SVG with improved rendering lifecycle handling
        function applyJitter() {
            const input = inputSvg.value;
            if (!input) {
                alert('Please paste SVG code first');
                return;
            }
            
            try {
                // Show loading indicator
                loadingIndicator.style.display = 'block';
                
                // Process SVG asynchronously to prevent UI blocking
                setTimeout(() => {
                    try {
                        const jitteredSvg = processSvgPaths(input);
                        outputSvg.value = jitteredSvg;
                        
                        // Update preview with proper SVG handling
                        updatePreview(jitteredSvg);
                        
                        // Show success message
                        showStatus('Jitter applied successfully!', 'success');
                    } catch (error) {
                        console.error('Error applying jitter:', error);
                        showStatus(`Error: ${error.message}`, 'error');
                    } finally {
                        // Hide loading indicator
                        loadingIndicator.style.display = 'none';
                    }
                }, 10);
            } catch (error) {
                console.error('Error applying jitter:', error);
                showStatus(`Error: ${error.message}`, 'error');
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Throttled version of applyJitter
        function throttledApplyJitter() {
            if (throttleTimer) {
                clearTimeout(throttleTimer);
            }
            throttleTimer = setTimeout(() => {
                applyJitter();
                throttleTimer = null;
            }, throttleDelay);
        }
        
        // Update preview with proper SVG handling and coordinate system preservation
        function updatePreview(svgContent) {
            // Clear container
            previewContainer.innerHTML = '';
            
            // Add loading indicator and coordinate overlay back
            previewContainer.appendChild(loadingIndicator);
            previewContainer.appendChild(coordinateOverlay);
            
            // Create a new SVG element
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = svgContent;
            const newSvg = tempDiv.querySelector('svg');
            
            if (newSvg) {
                // Preserve original viewBox if it exists, otherwise create one
                const originalViewBox = newSvg.getAttribute('viewBox');
                const originalWidth = newSvg.getAttribute('width');
                const originalHeight = newSvg.getAttribute('height');
                
                // Handle viewBox with a more comprehensive approach
                if (!originalViewBox) {
                    // Try to determine appropriate viewBox based on content
                    let viewBox = '0 0 200 200'; // Default fallback
                    
                    if (originalWidth && originalHeight) {
                        // Use original dimensions
                        const width = parseFloat(originalWidth) || 200;
                        const height = parseFloat(originalHeight) || 200;
                        viewBox = `0 0 ${width} ${height}`;
                    } else {
                        // Try to get bounding box of content
                        try {
                            // Temporarily add to DOM to get bbox
                            previewContainer.appendChild(newSvg);
                            const bbox = newSvg.getBBox();
                            previewContainer.removeChild(newSvg);
                            
                            if (bbox.width > 0 && bbox.height > 0) {
                                // Add padding to ensure content isn't cut off
                                const padding = 20;
                                viewBox = `${bbox.x - padding} ${bbox.y - padding} ${bbox.width + padding * 2} ${bbox.height + padding * 2}`;
                            }
                        } catch (e) {
                            console.log('Could not determine content bounds');
                        }
                    }
                    
                    newSvg.setAttribute('viewBox', viewBox);
                }
                
                // Ensure preserveAspectRatio is set for proper scaling
                newSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                
                // Apply CSS to make it fill the container
                newSvg.style.width = '100%';
                newSvg.style.height = '100%';
                
                // Add vector-effect to all graphical elements to prevent stroke scaling
                const graphicalElements = newSvg.querySelectorAll('path, line, circle, rect, polygon, polyline');
                graphicalElements.forEach(element => {
                    element.style.vectorEffect = 'non-scaling-stroke';
                });
                
                // Add to container
                previewContainer.appendChild(newSvg);
            }
        }
        
        // Copy result to clipboard
        function copyResult() {
            if (!outputSvg.value) {
                showStatus('No jittered SVG to copy', 'error');
                return;
            }
            
            navigator.clipboard.writeText(outputSvg.value)
                .then(() => {
                    showStatus('Copied to clipboard!', 'success');
                })
                .catch(err => {
                    showStatus(`Failed to copy: ${err.message}`, 'error');
                });
        }
        
        // Export SVG to file
        function exportSvg() {
            if (!outputSvg.value) {
                showStatus('No jittered SVG to export', 'error');
                return;
            }
            
            const blob = new Blob([outputSvg.value], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'jittered-svg.svg';
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus('SVG exported successfully!', 'success');
            }, 100);
        }
        
        // Zoom functions (removed for stable preview)
        function zoom(factor) {
            // Function intentionally left empty for stable preview
        }
        
        function updateTransform() {
            // Function intentionally left empty for stable preview
        }
        
        // Drag functions (removed for stable preview)
        function startDrag(e) {
            // Function intentionally left empty for stable preview
        }
        
        function drag(e) {
            // Function intentionally left empty for stable preview
        }
        
        function endDrag() {
            // Function intentionally left empty for stable preview
        }
        
        // Wheel function (removed for stable preview)
        function handleWheel(e) {
            // Function intentionally left empty for stable preview
        }
        
        // Navigation history functions
        function updateNavButtons() {
            // Function no longer needed
        }
        
        // Coordinate overlay
        function updateCoordinateOverlay(e) {
            const rect = previewContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert screen coordinates to SVG coordinates
            const svgElement = previewContainer.querySelector('svg');
            if (svgElement) {
                const viewBoxAttr = svgElement.getAttribute('viewBox');
                if (viewBoxAttr) {
                    const viewBoxValues = viewBoxAttr.split(' ').map(Number);
                    if (viewBoxValues.length === 4) {
                        const [viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight] = viewBoxValues;
                        
                        // Calculate SVG coordinates
                        const svgX = viewBoxX + (x - currentX) / currentScale;
                        const svgY = viewBoxY + (y - currentY) / currentScale;
                        
                        coordinateOverlay.textContent = `X: ${svgX.toFixed(1)}, Y: ${svgY.toFixed(1)}`;
                        coordinateOverlay.style.display = 'block';
                    }
                }
            }
        }
        
        // Drag and drop functions
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            dropZone.style.backgroundColor = '#e9e9e9';
        }
        
        function handleDrop(e) {
            e.preventDefault();
            dropZone.style.backgroundColor = '#f9f9f9';
            
            const files = e.dataTransfer.files;
            if (files.length) {
                handleFile(files[0]);
            }
        }
        
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length) {
                handleFile(files[0]);
            }
        }
        
        function handleFile(file) {
            if (file.type !== 'image/svg+xml' && !file.name.endsWith('.svg')) {
                alert('Please select an SVG file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                inputSvg.value = e.target.result;
                applyJitter();
            };
            reader.readAsText(file);
        }
        
        // Show status message
        function showStatus(message, type) {
            copyStatus.textContent = message;
            copyStatus.className = `status ${type}`;
            copyStatus.classList.remove('hidden');
            
            // Hide after 3 seconds
            setTimeout(() => {
                copyStatus.classList.add('hidden');
            }, 3000);
        }
        
        // Initialize event listeners
        function initEventListeners() {
            // Update value displays and apply jitter automatically
            jitterAmplitude.addEventListener('input', () => {
                amplitudeValue.textContent = jitterAmplitude.value;
                config.jitter_amplitude = parseFloat(jitterAmplitude.value);
                throttledApplyJitter();
            });
            
            segmentFrequency.addEventListener('input', () => {
                frequencyValue.textContent = parseFloat(segmentFrequency.value).toFixed(1);
                config.segment_frequency = parseFloat(segmentFrequency.value);
                throttledApplyJitter();
            });
            
            curvyLines.addEventListener('change', () => {
                config.curvy_lines = curvyLines.checked;
                throttledApplyJitter();
            });
            
            // Update when input SVG changes
            inputSvg.addEventListener('input', () => {
                throttledApplyJitter();
            });
            
            // Copy result button
            copyResultBtn.addEventListener('click', copyResult);
            
            // Export SVG button
            exportSvgBtn.addEventListener('click', exportSvg);
            
            // Drag and drop functionality
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('drop', handleDrop);
            
            // Dark mode toggle
            darkModeToggle.addEventListener('click', toggleDarkMode);
            
            // Coordinate overlay
            previewContainer.addEventListener('mousemove', updateCoordinateOverlay);
            previewContainer.addEventListener('mouseleave', () => {
                coordinateOverlay.style.display = 'none';
            });
        }
        
        // Dark mode functions
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            
            // Update toggle button icon
            if (document.body.classList.contains('dark-mode')) {
                darkModeToggle.textContent = 'â˜€ï¸';
                localStorage.setItem('darkMode', 'enabled');
            } else {
                darkModeToggle.textContent = 'ðŸŒ™';
                localStorage.setItem('darkMode', 'disabled');
            }
        }
        
        // Initialize with sample SVG
        window.addEventListener('load', () => {
            // Initialize event listeners
            initEventListeners();
            
            // Check for saved dark mode preference
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
                darkModeToggle.textContent = 'â˜€ï¸';
            }
            
            // Small delay to ensure DOM is fully loaded
            setTimeout(() => {
                applyJitter();
            }, 100);
        });
    </script>
</body>
</html>